using Blink3.Core.Constants;
using Blink3.Core.Entities;
using Blink3.Core.Enums;
using Blink3.Core.Extensions;
using Blink3.Core.Interfaces;
using Microsoft.Extensions.ObjectPool;
using SixLabors.Fonts;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Drawing.Processing;
using SixLabors.ImageSharp.Formats.Png;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;

namespace Blink3.Core.Services.Generators;

/// <summary>
///     Generates Wordle guess images.
/// </summary>
public class WordleGuessImageGenerator : IWordleGuessImageGenerator
{
    /// <summary>
    ///     Represents the size, in pixels, of each tile used in the Wordle guess image generation process.
    /// </summary>
    private const int TileSize = 128;

    /// <summary>
    ///     Represents the size of the font used for text rendering in Wordle guess images.
    /// </summary>
    private const int FontSize = 72;

    /// <summary>
    ///     The font size used to render icons in the Wordle guess image generator.
    /// </summary>
    private const int IconFontSize = 18;

    /// <summary>
    ///     The size of the margin used in the generated Wordle guess images.
    /// </summary>
    /// <remarks>
    ///     Represents the spacing, in pixels, between the edge of the image and its content.
    ///     This contributes to the layout design by ensuring an appropriate buffer between elements.
    /// </remarks>
    private const int MarginSize = 5;

    /// <summary>
    ///     Specifies the margin size, in pixels, used around the keyboard layout in the Wordle guess image generation process.
    /// </summary>
    private const int KeyboardMarginSize = 22;

    /// <summary>
    ///     Represents the size of a letter used in the generated Wordle guess image.
    /// </summary>
    /// <remarks>
    ///     This value is calculated by subtracting twice the margin size from the tile size to ensure
    ///     proper spacing and alignment of the letters within their respective tiles.
    /// </remarks>
    private const int LetterSize = TileSize - 2 * MarginSize;

    /// <summary>
    ///     Represents the height of the image generated by the WordleGuessImageGenerator class.
    /// </summary>
    /// <remarks>
    ///     The height is derived by considering the size of individual tiles and the margins surrounding the tiles.
    /// </remarks>
    private const int ImageHeight = TileSize + 2 * MarginSize;

    /// <summary>
    ///     Represents the Y-coordinate of the rectangle used to draw a letter tile in the WordleGuessImageGenerator class.
    /// </summary>
    private const int RectY = 2 * MarginSize;

    /// <summary>
    ///     The Y-coordinate position of the icon within a tile in the WordleGuessImageGenerator class.
    /// </summary>
    private const float IconY = RectY + MarginSize;

    /// <summary>
    ///     The base font used for rendering text in Wordle guess image generation.
    /// </summary>
    private static readonly Font BaseFont = LoadFont("Geologica.ttf", FontSize);

    /// <summary>
    ///     Font used for rendering icons in the Wordle guess image generator.
    /// </summary>
    private static readonly Font IconFont = LoadFont("Icons.ttf", IconFontSize);

    /// <summary>
    ///     Configuration options for rendering text, such as alignment and wrapping.
    /// </summary>
    private static readonly TextOptions TextOptions = new(BaseFont)
    {
        HorizontalAlignment = HorizontalAlignment.Center,
        VerticalAlignment = VerticalAlignment.Center,
        WrappingLength = LetterSize
    };

    /// <summary>
    ///     Configuration for rendering text within an icon, specifying alignment and font settings.
    /// </summary>
    private static readonly TextOptions IconTextOptions = new(IconFont)
    {
        HorizontalAlignment = HorizontalAlignment.Center,
        VerticalAlignment = VerticalAlignment.Center
    };

    private static readonly PngEncoder FastPngEncoder = new()
    {
        CompressionLevel = PngCompressionLevel.BestSpeed,
        BitDepth = PngBitDepth.Bit8,
        FilterMethod = PngFilterMethod.None
    };
    
    /// <summary>
    ///     Loads a font with the specified name and size.
    /// </summary>
    /// <param name="fontName">The name of the font to load.</param>
    /// <param name="size">The size of the font to create.</param>
    /// <returns>A Font object representing the loaded font with the specified size.</returns>
    private static Font LoadFont(string fontName, int size)
    {
        FontCollection fontCollection = new();
        string fontPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Fonts", fontName);
        FontFamily fontFamily = fontCollection.Add(fontPath);
        return fontFamily.CreateFont(size);
    }

    /// <summary>
    ///     Generates an image representing a WordleGuess object asynchronously.
    /// </summary>
    /// <param name="guess">The WordleGuess object to generate an image for.</param>
    /// <param name="options">The options for generating the image.</param>
    /// <param name="outStream">The memory stream to save the created image to.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>A Task that represents the asynchronous operation.</returns>
    public async Task GenerateImageAsync(WordleGuess guess,
        WordleGuessImageGeneratorOptions options,
        MemoryStream outStream,
        CancellationToken cancellationToken = default)
    {
        // Create a new image and save it to the memory stream
        await CreateAndSaveImageAsync(guess, options, outStream, cancellationToken);
    }

    /// <summary>
    ///     Creates and saves a status image based on the given Wordle object's guesses.
    /// </summary>
    /// <param name="wordle">The Wordle object containing the guesses to be represented in the image.</param>
    /// <param name="outStream">The memory stream to save the generated status image to.</param>
    /// <param name="cancellationToken">The cancellation token to monitor for cancellation requests.</param>
    /// <returns>A Task that represents the asynchronous operation.</returns>
    public async Task CreateAndSaveStatusImageAsync(Wordle wordle,
        MemoryStream outStream,
        CancellationToken cancellationToken)
    {
        // QWERTY keyboard layout rows
        List<string> keyboardRows =
        [
            "qwertyuiop",
            "asdfghjkl",
            "zxcvbnm"
        ];

        HashSet<char> invalidLetters = [];
        foreach (WordleGuess guess in wordle.Guesses)
        foreach (IGrouping<char, WordleLetter> letterGroup in guess.Letters.GroupBy(letter => letter.Letter))
            // Check if all occurrences of the letter are incorrect
            if (letterGroup.All(l => l.State == WordleLetterStateEnum.Incorrect))
                invalidLetters.Add(letterGroup.Key);

        // Calculate image dimensions
        int imageWidth = keyboardRows.Max(row => row.Length) * TileSize + 2 * KeyboardMarginSize;
        int imageHeight = keyboardRows.Count * TileSize + 2 * KeyboardMarginSize;

        using Image<Rgba32> image = new(imageWidth, imageHeight);

        image.Mutate(im =>
        {
            // Draw each keyboard row
            for (int rowIndex = 0; rowIndex < keyboardRows.Count; rowIndex++)
            {
                string row = keyboardRows[rowIndex];
                int rowWidthPx = row.Length * TileSize;

                // Calculate starting X position to center the row
                int startX = (imageWidth - rowWidthPx) / 2;

                for (int colIndex = 0; colIndex < row.Length; colIndex++)
                {
                    // Calculate the X and Y positions for the tile
                    int tileX = startX + colIndex * TileSize;
                    int tileY = rowIndex * TileSize + KeyboardMarginSize;
                    char letter = row[colIndex];

                    // Determine the tile color:
                    // If the letter is in the invalid set, use the default muted color.
                    // Otherwise, highlight it (it's valid).
                    Color tileColor = invalidLetters.Contains(letter)
                        ? WordleImageConstants.KeyUnavailableColour // Muted color for unavailable letters
                        : WordleImageConstants.KeyAvailableColour; // Highlight available letters

                    // Draw the keyboard tile
                    DrawKeyboardTile(im, char.ToUpper(letter), tileX, tileY, tileColor);
                }
            }
        });

        await image.SaveAsync(outStream, FastPngEncoder, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    ///     Draws a single keyboard tile with the specified letter, position, and color.
    /// </summary>
    /// <param name="im">The image processing context to apply the drawing operation on.</param>
    /// <param name="letter">The letter to display within the keyboard tile.</param>
    /// <param name="x">The X-coordinate of the tile's top-left corner.</param>
    /// <param name="y">The Y-coordinate of the tile's top-left corner.</param>
    /// <param name="tileColor">The color to fill the keyboard tile.</param>
    private static void DrawKeyboardTile(IImageProcessingContext im,
        char letter,
        int x,
        int y,
        Color tileColor)
    {
        // Draw and fill the tile rectangle
        im.Fill(tileColor, new Rectangle(x, y, LetterSize, LetterSize));

        // Measure the text size and position the letter in the center of the tile
        string text = letter.ToString();
        FontRectangle textSize = TextMeasurer.MeasureAdvance(text, TextOptions);
        float textX = x + (LetterSize - textSize.Width) / 2;
        float textY = y + (LetterSize - textSize.Height) / 2;

        // Draw the letter inside the tile
        im.DrawText(text, BaseFont, WordleImageConstants.TextColour, new PointF(textX, textY));
    }

    /// <summary>
    ///     Creates and saves an image representing a Wordle guess asynchronously.
    /// </summary>
    /// <param name="guess">The Wordle guess containing the letters of the guess.</param>
    /// <param name="options">The options for configuring the image generation process.</param>
    /// <param name="outStream">The memory stream where the generated image will be saved.</param>
    /// <param name="cancellationToken">The cancellation token used to cancel the asynchronous operation.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    private static async Task CreateAndSaveImageAsync(WordleGuess guess,
        WordleGuessImageGeneratorOptions options,
        MemoryStream outStream,
        CancellationToken cancellationToken)
    {
        // Calculate image width
        int imageWidth = TileSize * guess.Letters.Count + 2 * MarginSize;

        // Create new image
        using Image<Rgba32> image = new(imageWidth, ImageHeight);

        image.Mutate(im =>
        {
            im.Fill(options.BackgroundColour);
            for (int i = 0; i < guess.Letters.Count; i++)
                DrawLetterAndIcon(im, guess.Letters[i], i, options);
        });

        // Save image to memory stream
        await image.SaveAsync(outStream, FastPngEncoder, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    ///     Draws a letter and an icon on the image using the specified parameters.
    /// </summary>
    /// <param name="im">The image processing context.</param>
    /// <param name="letter">The WordleLetter object representing the letter to be drawn.</param>
    /// <param name="index">The index of the letter.</param>
    /// <param name="options">The WordleGuessImageGeneratorOptions object containing the drawing options.</param>
    private static void DrawLetterAndIcon(IImageProcessingContext im,
        WordleLetter letter,
        int index,
        WordleGuessImageGeneratorOptions options)
    {
        // Draw and fill letter tile
        int rectX = index * TileSize + 2 * MarginSize;
        Color tileColour = letter.State switch
        {
            WordleLetterStateEnum.Correct => options.CorrectTileColour,
            WordleLetterStateEnum.Misplaced => options.MisplacedTileColour,
            _ => options.IncorrectTileColour
        };
        im.Fill(tileColour, new Rectangle(rectX, RectY, LetterSize, LetterSize));

        // Measure the text size, write letter in center of tile
        string text = letter.Letter.ToString().ToUpper();
        FontRectangle textSize = TextMeasurer.MeasureAdvance(text, TextOptions);
        float textX = rectX + (LetterSize - textSize.Width) / 2;
        float textY = RectY + (LetterSize - textSize.Height) / 2;
        im.DrawText(text, BaseFont, options.TextColour, new PointF(textX, textY));

        // Draw tile icon
        string icon = letter.State.GetIcon().ToString();
        FontRectangle iconSize = TextMeasurer.MeasureBounds(icon, IconTextOptions);
        float iconX = rectX + LetterSize - iconSize.Width - MarginSize;
        im.DrawText(icon, IconFont, options.TextColour, new PointF(iconX, IconY));
    }
}